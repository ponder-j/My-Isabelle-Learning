# Isabelle 元逻辑规则详解

## 目录

- [基本符号说明](#基本符号说明)
- [冒号的两种含义](#冒号的两种含义)
- [类型规则](#类型规则)
- [推理规则](#推理规则)
- [Curry-Howard 同构](#curry-howard-同构)
- [Isabelle 语法参考](#isabelle-语法参考)

---

## 基本符号说明

### 元逻辑与对象逻辑符号对比

| 层次               | 全称量词    | 蕴涵                | 等式       |
| ------------------ | ----------- | ------------------- | ---------- |
| **对象逻辑** | ∀ (forall) | → 或 ⟶            | =          |
| **元逻辑**   | ⋀ (And)    | ⟹ (Longrightarrow) | ≡ (equiv) |

### 基本符号

- `::` - **类型标注**（type annotation），表示"具有类型"
- `:` - **判断关系**（judgment），表示"是...的证明"
- `⇒` - **函数类型**的蕴含
- `⋀` - **元全称量词**，元层面的"对所有"
- `⟹` - **元蕴涵**，元逻辑层面的蕴含
- `[x]` - **假设/上下文**，方括号表示局部假设
- 横线 - **推理规则**，上面是前提，下面是结论
- `⋮` - 表示中间可能有多步推导

---

## 冒号的两种含义

### 1. `::` 双冒号 - 类型标注

表示"**具有类型**"（has type）

```isabelle
x :: α        (* x 的类型是 α *)
λx :: α. ...  (* lambda 抽象，x 的类型是 α *)
```

这是**静态的类型声明**，在编译时检查。

### 2. `:` 单冒号 - 判断/证明关系

表示"**是...的证明/实例**"（is a proof of / inhabits）

```isabelle
p(x) : B(x)   (* p(x) 是命题 B(x) 的一个证明 *)
```

这是**动态的证明关系**，在逻辑层面。

### 具体例子分析

#### 在 `p(x) : B(x)` 中：

- **p(x)** 是一个**证明项**（proof term）
- **B(x)** 是一个**命题/类型**（proposition/type）
- **冒号** 表示"p(x) 是 B(x) 的一个证明"

**类比理解**：就像说"5 是自然数"，p(x) 是证明，B(x) 是被证明的命题。

#### 在 `(λx :: α. p(x)) : (⋀x :: α. B(x))` 中：

```isabelle
(λx :: α. p(x)) : (⋀x :: α. B(x))
  ─┬─  ──┬──         ──┬──  ──┬──
   │     │             │      │
   │     └─ 类型标注   │      └─ 对每个 x，B(x) 是一个命题
   │        (::)       │
   └─ lambda 抽象     └─ 全称量化类型
   
整体的 : 表示判断关系
```

**含义**：

- `λx :: α. p(x)` 是一个**依赖函数**，对每个类型为 α 的 x，产生 p(x)
- `⋀x :: α. B(x)` 是一个**依赖类型**，表示"对所有 x :: α，B(x) 成立"
- 整个式子说：这个 lambda 函数**是**全称命题的证明

---

## 类型规则

### 1. ⇒引入规则 (Implication Introduction)

```
[x :: α]
   ⋮
b(x) :: β
─────────────────────
λx :: α. b(x) :: α ⇒ β
```

**含义**：

- 假设存在类型为 α 的变量 x
- 在这个假设下，能推导出 b(x) 具有类型 β
- 那么可以构造函数 λx.b(x)，它的类型是 α ⇒ β
- 相当于"如果 x:α 能推出 b(x):β，则 λx.b(x) 是从 α 到 β 的函数"

**实例**：

```isabelle
-- 如果对任意自然数 n，n+1 也是自然数
-- 则 λn. n+1 是从自然数到自然数的函数
```

### 2. ⇒消除规则 (Implication Elimination，函数应用)

```
b :: α ⇒ β    a :: α
─────────────────────
(b a) :: β
```

**含义**：

- 如果 b 是从 α 到 β 的函数
- a 的类型是 α
- 那么应用 b 到 a，结果 (b a) 的类型是 β

**实例**：

```isabelle
-- 如果 f :: ℕ ⇒ ℕ 且 5 :: ℕ
-- 则 (f 5) :: ℕ
```

### 3. ⋀引入规则 (Universal Quantification Introduction)

```
[x :: α]
   ⋮
p(x) : B(x)
─────────────────────────────
(λx :: α. p(x)) : (⋀x :: α. B(x))
```

**含义**：

- 对任意类型为 α 的 x（不依赖于 x 的具体值）
- 如果能证明 p(x) 满足性质 B(x)
- 则可以得到全称量化的结论：对所有 x，B(x) 成立

**注意**：这里展示了**依赖类型**的特性，B(x) 的类型依赖于 x 的值。

### 4. ⋀消除规则 (Universal Quantification Elimination)

```
p : (⋀x :: α. B(x))    a :: α
──────────────────────────────
(p a) : B(a)
```

**含义**：

- 如果 p 对所有 x:α 都满足 B(x)
- 那么对具体的 a:α，将 p 应用到 a 得到的 (p a) 满足 B(a)
- 这是**全称实例化**

**实例**：

```isabelle
-- 如果证明了"对所有自然数 n，n ≥ 0"
-- 那么对具体的 5，可以得到 "5 ≥ 0"
```

### 5. ⇒引入规则（命题层面）

```
[p : A]
   ⋮
q : B
─────────────────
(λp : A. q) : (A ⟹ B)
```

**含义**：

- 假设命题 A 成立（p 是 A 的证明）
- 在此假设下能证明 B（q 是 B 的证明）
- 则可以构造 A 蕴含 B 的证明
- 这是**条件证明**的形式化

“我构造了一个函数，它接受 A 的任意证明 p 作为输入，然后返回 B 的证明 q”

### 6. ⇒消除规则（命题层面，Modus Ponens）

```
p : A ⟹ B    q : A
──────────────────
(p q) : B
```

**含义**：

- 如果有 A 蕴含 B 的证明 p
- 又有 A 的证明 q
- 则可以得到 B 的证明
- 这就是经典的**分离规则**（Modus Ponens）

---

## 推理规则

### 1. ⋀引入规则

```
[x]
 ⋮
B(x)
─────────
⋀x. B(x)
```

**含义**：

- 对任意的 x（不依赖于 x 的具体值）
- 如果能证明 B(x)
- 则可以得到"对所有 x，B(x) 都成立"

**关键点**：x 必须是**任意的**，证明过程不能依赖 x 的特殊性质。

**错误示例**：

```isabelle
-- 错误：不能从 "5 是偶数" 推出 "所有数都是偶数"
-- 因为 5 不是任意选择的
```

### 2. ⇒引入规则

```
[A]
 ⋮
B
───────
A ⟹ B
```

**含义**：

- 假设 A 成立
- 在此假设下能推出 B
- 则可以得到"A 蕴含 B"
- 此时假设 A 被"解除"（discharged）

**直观理解**：

```
要证明 "下雨 ⟹ 地湿"
证明：
  [假设：下雨]
     ⋮
  推导：地湿
  ─────────
  ∴ 下雨 ⟹ 地湿
```

### 3. Spec 规则

```
⋀x. B(x)
─────────
  B(a)
```

### 4. 分离规则

```
A ⟹ B A
─────────
   B
```

**含义**：

---

## Curry-Howard 同构

### 命题即类型，证明即程序

在 Curry-Howard 同构下，逻辑和类型理论有完美的对应关系：

| 逻辑层面         | 类型理论层面              | 符号示例                  |
| ---------------- | ------------------------- | ------------------------- |
| 命题 B           | 类型 B                    | `B : Type`              |
| B 的证明         | 类型 B 的值/项            | `p : B`                 |
| 命题 A ⟹ B      | 函数类型 A → B           | `f : A → B`            |
| A ∧ B (合取)    | 积类型 A × B             | `(a, b) : A × B`       |
| A ∨ B (析取)    | 和类型 A + B              | `Left a : A + B`        |
| ∀x. B(x) (全称) | 依赖函数类型 Πx:α. B(x) | `λx. p(x) : Πx. B(x)` |
| ∃x. B(x) (存在) | 依赖积类型 Σx:α. B(x)   | `(a, p) : Σx. B(x)`    |
| ⊥ (假)          | 空类型 Empty              | -                         |
| ⊤ (真)          | 单元类型 Unit             | `() : Unit`             |

### 关键理解

- `p : B` 读作："p 是 B 的证明" = "p 是类型 B 的一个值"
- `x :: α` 读作："x 声明为类型 α"
- 证明一个命题 = 构造该类型的一个项
- 命题为真 = 该类型非空（有值存在）
- 命题为假 = 该类型为空（无法构造值）

### 实例对比

#### 逻辑层面

```
命题：对所有自然数 n，n + 0 = n
证明：对任意 n，通过归纳法证明...
```

#### 类型理论层面

```isabelle
类型：⋀n :: ℕ. (n + 0 = n)
项：λn :: ℕ. <归纳证明> : (⋀n :: ℕ. (n + 0 = n))
```

---

## Isabelle 语法参考

### 元逻辑符号输入

在 Isabelle/jEdit 中输入元逻辑符号：

```isabelle
(* 元逻辑符号 *)
\<And>              (* ⋀ 元全称量词 *)
\<Longrightarrow>   (* ⟹ 元蕴涵 *)
\<equiv>            (* ≡ 元等式 *)

(* 对象逻辑符号 *)
\<forall>           (* ∀ 全称量词 *)
\<longrightarrow>   (* ⟶ 蕴涵 *)
=                   (* = 等式 *)
```

### ASCII 替代形式

```isabelle
(* 纯 ASCII 写法 *)
!!              (* 相当于 ⋀ *)
==>             (* 相当于 ⟹ *)
==              (* 相当于 ≡ *)

ALL             (* 相当于 ∀ *)
-->             (* 相当于 ⟶ *)
```

### Unicode 字符代码

| 符号 | Unicode | HTML 实体    |
| ---- | ------- | ------------ |
| ⋀   | U+22C0  | `&#x22C0;` |
| ⟹   | U+27F9  | `&#x27F9;` |
| ≡   | U+2261  | `&equiv;`  |
| ∀   | U+2200  | `&forall;` |
| →   | U+2192  | `&rarr;`   |
| ⟶   | U+27F6  | `&#x27F6;` |

### 示例代码

```isabelle
(* Unicode 形式 *)
lemma example1:
  "⋀x. P x ⟹ Q x"
  
(* ASCII 形式，等价 *)
lemma example2:
  "!!x. P x ==> Q x"

(* 类型标注示例 *)
lemma example3:
  fixes f :: "nat ⇒ nat"
  shows "⋀n. f n ≥ 0"
```

---

## 直观理解：数学证明类比

想象你在写一个传统的数学证明：

```
命题：对所有 x，如果 x > 0，则 x² > 0

证明：
  设 x 为任意实数，且 x > 0    <- [x :: α] 
```
