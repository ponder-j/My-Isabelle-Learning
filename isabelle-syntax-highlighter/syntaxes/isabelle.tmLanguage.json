{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "Isabelle",
  "scopeName": "source.isabelle",
  "patterns": [
    {
      "include": "#comments"
    },
    {
      "include": "#strings"
    },
    {
      "include": "#theory-header"
    },
    {
      "include": "#keywords"
    },
    {
      "include": "#proof-keywords"
    },
    {
      "include": "#locale-keywords"
    },
    {
      "include": "#datatype-keywords"
    },
    {
      "include": "#symbols"
    },
    {
      "include": "#operators"
    },
    {
      "include": "#type-annotations"
    },
    {
      "include": "#numbers"
    },
    {
      "include": "#identifiers"
    }
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.line.double-hyphen.isabelle",
          "match": "--.*$"
        },
        {
          "name": "comment.block.isabelle",
          "begin": "\\(\\*",
          "end": "\\*\\)",
          "patterns": [
            {
              "include": "#comments"
            }
          ]
        }
      ]
    },
    "strings": {
      "patterns": [
        {
          "name": "string.quoted.double.isabelle",
          "begin": "\"",
          "end": "\"",
          "patterns": [
            {
              "name": "constant.character.escape.isabelle",
              "match": "\\\\."
            }
          ]
        }
      ]
    },
    "theory-header": {
      "patterns": [
        {
          "name": "keyword.control.theory.isabelle",
          "match": "\\b(theory|imports|begin|end)\\b"
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "name": "keyword.control.isabelle",
          "match": "\\b(definition|lemma|theorem|corollary|proposition|fun|function|primrec|datatype|typedef|type_synonym|class|instance|instantiation|consts|defs|axioms|declare|text|section|subsection|subsubsection|chapter|paragraph|subparagraph|abbreviation|notation|no_notation|where|and|is|shows|assumes|fixes|obtains|notes|includes|defines)\\b"
        }
      ]
    },
    "proof-keywords": {
      "patterns": [
        {
          "name": "keyword.control.proof.isabelle",
          "match": "\\b(proof|qed|by|apply|done|sorry|oops|next|case|have|show|thus|hence|then|moreover|ultimately|finally|also|from|with|using|unfolding|simp|auto|blast|force|fastforce|clarsimp|safe|rule|erule|drule|frule|induct|induction|cases|case_tac|subst|subgoal_tac|rename_tac|rotate_tac|thin_tac|cut_tac|insert|assume|presume|obtain|guess|fix|let|consider|define|note|write)\\b"
        }
      ]
    },
    "locale-keywords": {
      "patterns": [
        {
          "name": "keyword.control.locale.isabelle",
          "match": "\\b(locale|context|interpretation|interpret|sublocale|global_interpretation|in)\\b"
        }
      ]
    },
    "datatype-keywords": {
      "patterns": [
        {
          "name": "keyword.control.datatype.isabelle",
          "match": "\\b(inductive|inductive_set|coinductive|coinductive_set|codatatype|record|nominal_datatype|quickcheck_generator|nitpick_params|sledgehammer_params)\\b"
        }
      ]
    },
    "symbols": {
      "patterns": [
        {
          "name": "constant.language.symbol.isabelle",
          "match": "\\\\<[a-zA-Z_][a-zA-Z0-9_']*>"
        },
        {
          "name": "constant.language.symbol.bracket.isabelle",
          "match": "\\\\<(lparr|rparr|lbrakk|rbrakk|langle|rangle)>"
        }
      ]
    },
    "operators": {
      "patterns": [
        {
          "name": "keyword.operator.logical.isabelle",
          "match": "(\\\\<and>|\\\\<or>|\\\\<not>|\\\\<longrightarrow>|\\\\<longleftarrow>|\\\\<longleftrightarrow>|\\\\<Rightarrow>|\\\\<Leftarrow>|\\\\<Leftrightarrow>|\\\\<forall>|\\\\<exists>|\\\\<nexists>)"
        },
        {
          "name": "keyword.operator.set.isabelle",
          "match": "(\\\\<in>|\\\\<notin>|\\\\<subset>|\\\\<subseteq>|\\\\<supset>|\\\\<supseteq>|\\\\<union>|\\\\<inter>|\\\\<setminus>|\\\\<Union>|\\\\<Inter>)"
        },
        {
          "name": "keyword.operator.arithmetic.isabelle",
          "match": "(\\\\<le>|\\\\<ge>|\\\\<noteq>|\\\\<approx>|\\\\<equiv>|\\\\<sim>|\\\\<simeq>|\\\\<propto>|\\\\<div>|\\\\<times>|\\\\<cdot>|\\\\<oplus>|\\\\<ominus>|\\\\<otimes>|\\\\<oslash>)"
        },
        {
          "name": "keyword.operator.lambda.isabelle",
          "match": "(\\\\<lambda>|\\\\<mu>|\\\\<nu>|\\\\<Lambda>|\\\\<Mu>|\\\\<Nu>)"
        },
        {
          "name": "keyword.operator.misc.isabelle",
          "match": "(\\\\<bottom>|\\\\<top>|\\\\<sqsubseteq>|\\\\<sqsupseteq>|\\\\<parallel>|\\\\<asymp>|\\\\<bowtie>|\\\\<triangleleft>|\\\\<triangleright>)"
        },
        {
          "name": "keyword.operator.simple.isabelle",
          "match": "(=|\\+|\\-|\\*|/|<|>|&|\\||@|#|\\^|!|\\?|~)"
        }
      ]
    },
    "type-annotations": {
      "patterns": [
        {
          "name": "support.type.isabelle",
          "match": "::[^:]*",
          "patterns": [
            {
              "name": "punctuation.separator.type.isabelle",
              "match": "::"
            }
          ]
        },
        {
          "name": "support.type.builtin.isabelle",
          "match": "\\b(bool|nat|int|real|string|char|unit|prop|set|list|option|sum|prod|fun)\\b"
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.isabelle",
          "match": "\\b[0-9]+(\\.[0-9]+)?([eE][+-]?[0-9]+)?\\b"
        }
      ]
    },
    "identifiers": {
      "patterns": [
        {
          "name": "variable.other.isabelle",
          "match": "\\b[a-zA-Z_][a-zA-Z0-9_']*\\b"
        },
        {
          "name": "variable.other.primed.isabelle",
          "match": "\\?[a-zA-Z_][a-zA-Z0-9_']*"
        }
      ]
    }
  }
}